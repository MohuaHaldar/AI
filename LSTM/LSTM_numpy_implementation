import numpy as np


# implement softmax
def sftmax(x):
    e=np.exp(x-np.max(x))
    return e/np.sum(e, axis=0)

# implement tanh function
def tanh(x):
    ex=np.exp(x)
    ex1=np.exp(-x)
    return (ex-ex1)/(ex+ex1)

# implement sigmoid function
def sigmoid(x):
    e=np.exp(-x)
    return 1/(1+e)

# implement rnn forward propagation
def fwdProp(hprev, xt, params):
    cache=[]
    # get the parameters
    U=params['U']
    W=params['W']
    V=params['V']
    bx=params['bx']
    by=params['by']
    # calculate the hidden state
    ht=tanh(np.dot(U.T,xt)+np.dot(W,hprev)+ bx)
    yt=sftmax(np.dot(V, ht)+by)
    cache.append((hprev, ht, xt, params))
    return ht, yt, cache

# test the code 
xt=np.random.randn(500, 200)
hprev=np.random.randn(500,200)
params={}
params['U']=np.random.rand(200, 500)
params['W']=np.random.rand(200, 500)
params['V']=np.random.rand(200,200)
params['bx']=np.random.randn(200)
params['by']=np.random.randn(200)

fwdProp(hprev, xt, params)

# compute the fwd prop for whole sequence
def fwdPropSeq(x,h0,params):
    Nx,M,T=x.shape
    
    y_n, h_n=params['V'].shape
    h_n,h_n=params['W'].shape
    Ypred=np.zeros((y_n,M,T))
    H=np.zeros((h_n,M,T))
    caches=[]
    
    h_next=h0
    for t in range(T):
        h_next,yt, cache=fwdProp(h_next, x[:,:,t], params)
        Ypred[:,:,t]=yt
        H[:,:,t]=h_next
        caches.append(cache)
    return Ypred, H, caches

# test the code 
x=np.random.randn(500, 200, 10)
h0=np.random.randn(300,200)
params={}
params['U']=np.random.rand(500, 300)
params['W']=np.random.rand(300, 300)
params['V']=np.random.rand(200,300)
params['bx']=np.random.randn(300,1)
params['by']=np.random.randn(200,1)
fwdPropSeq(x,h0, params)

h=np.random.randn(300,200)
o=np.dot(params['U'].T,x[:,:,0])+np.dot(params['W'].T,h)

o+params['bx']

LSTM implementation

import numpy as np

# we will assume that the entire sequence of input as a tuple (n,m,T), where
# n is the size of the vocabulary, m is the size of the mini batch, and T is the
# total time sequence. 

# we will create a function lstm fwd prop

def LSTMfwdProp(X, h0,c0, params):
    
    '''
    X= the entire input sequence of the shape (n, m, T).
    h0= the initial hidden state.
    params= the list of parameters that consist of Wxf, Whf, Wxi, Whi, Wxc, Whc, Wco,Who,
    bf,bi,bc,bo.
    
    '''
    # get the dimensions of X
    n, m, T=X.shape
    
    # get the shape of h
    h, h = params['Whf'].shape
    
    # get the shape of y
    h,y=params['Wy'].shape
    
    # initialize tensors h, c, and  y
    
    c=np.zeros((h,m,T))
    h=np.zeros((h,m,T))    
    y=np.zeros((y,m,T))
    
    
    # read the parameters
    Wxf=params['Wxf']
    Wxi=params['Wxi']
    Wxc=params['Wxc']
    Wxo=params['Wxo']
    Whf=params['Whf']
    Whi=params['Whi']
    Whc=params['Whc']
    Who=params['Who']
    Wy=params['Wy']
    bf=params['bf']
    bi=params['bi']
    bc=params['bc']
    bo=params['bo']
    by=params['by']
    
    
    hprev=h0
    cprev=c0
    # for each timestep calculate the forget gate, input gate, output gate
    for t in range(T):
        xt=X[:,:,t]  
        # calculate the forget gate
        ft= sigmoid(np.dot(Wxf.T, xt) + np.dot(Whf.T, hprev)+bf)
        # calculate the input gate
        it=sigmoid(np.dot(Wxi.T, xt) + np.dot(Whi.T, hprev) + bi)
        # calculate the input modulation gate
        c1t=tanh(np.dot(Wxc.T, xt)+ np.dot(Whc.T,hprev) + bc)
        # calculate the output gate
        ot=sigmoid(np.dot(Wxo.T,xt)+np.dot(Who.T,hprev)+bo)
        # calculate the next cell state
        ct=cprev * ft + it * c1t
        # calculate the next hidden state
        ht=ot * tanh(ct)
        # calculate the predicted value
        ytpred=sftmax(np.dot(Wy.T,ht)+by)
        
        # add the computations of timestamp t into respective variables
        h[:,:,t]=ht
        c[:,:,t]=ct
        y[:,:,t]=ytpred
        
        # set the present hidden state as the new hprev
        hprev=ht
    return h, c, y
        
        


# Test the forward propagation function
X=np.random.randn(8,4,10)
h0=np.random.randn(5,4)
c0=np.random.randn(5,4)
params['Wxf']=np.random.randn(8,5)
params['Wxi']=np.random.randn(8,5)
params['Wxc']=np.random.randn(8,5)
params['Wxo']=np.random.randn(8,5)
params['Whf']=np.random.randn(5,5)
params['Whi']=np.random.randn(5,5)
params['Whc']=np.random.randn(5,5)
params['Who']=np.random.randn(5,5)
params['Wy']=np.random.randn(5,4)
params['bf']=np.random.randn(5,1)
params['bi']=np.random.randn(5,1)
params['bc']=np.random.randn(5,1)
params['bo']=np.random.randn(5,1)
params['by']=np.random.randn(4,1)

LSTMfwdProp(X,h0,c0,params)

